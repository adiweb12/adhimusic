package com.example.musicplayer

import android.Manifest
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.os.IBinder
import android.widget.ImageButton
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.Toast
import androidx.activity.ComponentActivity
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import androidx.media3.common.Player
import androidx.media3.session.MediaController
import androidx.media3.session.SessionToken
import kotlinx.coroutines.*
import kotlin.time.Duration.Companion.milliseconds

class MainActivity : ComponentActivity() {

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)

    private lateinit var recycler: RecyclerView
    private lateinit var miniBar: LinearLayout
    private lateinit var miniTitle: TextView
    private lateinit var miniArtist: TextView
    private lateinit var miniProgress: ProgressBar
    private lateinit var btnPlayPause: ImageButton
    private lateinit var btnNext: ImageButton
    private lateinit var btnPrev: ImageButton
    private lateinit var btnShuffle: ImageButton
    private lateinit var btnRepeat: ImageButton

    private var controller: MediaController? = null
    private var songs: List<Song> = emptyList()

    private val requestPerm = registerForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { res ->
        val granted = res.values.any { it }
        if (granted) loadAndShowSongs() else {
            Toast.makeText(this, "Permission required to read music.", Toast.LENGTH_LONG).show()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main) // generated by workflow

        recycler = findViewById(R.id.recyclerView)
        recycler.layoutManager = LinearLayoutManager(this)

        // Mini-player views (we’ll add into activity_main via workflow or dynamically)
        miniBar = LinearLayout(this).apply {
            orientation = LinearLayout.VERTICAL
            setPadding(24, 24, 24, 24)
            elevation = 10f
            alpha = 0.98f
            translationZ = 16f
            // attach to root
            (findViewById<LinearLayout>(android.R.id.content)?.getChildAt(0) as? LinearLayout)
                ?.addView(this, 0)
        }
        miniTitle = TextView(this).also { miniBar.addView(it) }
        miniArtist = TextView(this).also { miniBar.addView(it) }
        miniProgress = ProgressBar(this, null, android.R.attr.progressBarStyleHorizontal)
            .also { miniBar.addView(it) }

        btnPlayPause = ImageButton(this).also { miniBar.addView(it) }
        btnNext = ImageButton(this).also { miniBar.addView(it) }
        btnPrev = ImageButton(this).also { miniBar.addView(it) }
        btnShuffle = ImageButton(this).also { miniBar.addView(it) }
        btnRepeat = ImageButton(this).also { miniBar.addView(it) }

        if (hasAudioPermission()) {
            startService(Intent(this, PlayerService::class.java))
            connectController()
            loadAndShowSongs()
        } else {
            askAudioPermission()
        }
    }

    private fun hasAudioPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= 33) {
            ContextCompat.checkSelfPermission(this, Manifest.permission.READ_MEDIA_AUDIO) ==
                    PackageManager.PERMISSION_GRANTED
        } else {
            ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) ==
                    PackageManager.PERMISSION_GRANTED
        }
    }

    private fun askAudioPermission() {
        if (Build.VERSION.SDK_INT >= 33) {
            requestPerm.launch(arrayOf(Manifest.permission.READ_MEDIA_AUDIO))
        } else {
            requestPerm.launch(arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE))
        }
    }

    private fun loadAndShowSongs() {
        songs = MusicRepository.loadAllSongs(this)
        recycler.adapter = MusicAdapter(songs) { song, _ ->
            controller?.let {
                // Build a new queue by sending items directly is simpler via PlaybackManager.
                // We’ll just start service (already running) and let controller play by URI:
                it.setMediaItem(androidx.media3.common.MediaItem.fromUri(song.contentUri))
                it.prepare()
                it.play()
            }
        }
    }

    private fun connectController() {
        scope.launch {
            val token = SessionToken(this@MainActivity, ComponentName(this@MainActivity, PlayerService::class.java))
            controller = MediaController.Builder(this@MainActivity, token).buildAsync().await()
            bindControllerListeners()
        }
    }

    private fun bindControllerListeners() {
        val c = controller ?: return
        c.addListener(object : Player.Listener {
            override fun onMediaMetadataChanged(mediaMetadata: androidx.media3.common.MediaMetadata) {
                miniTitle.text = mediaMetadata.title ?: "Playing…"
                miniArtist.text = mediaMetadata.artist ?: ""
            }

            override fun onIsPlayingChanged(isPlaying: Boolean) {
                btnPlayPause.setImageResource(
                    if (isPlaying) android.R.drawable.ic_media_pause
                    else android.R.drawable.ic_media_play
                )
            }

            override fun onEvents(player: Player, events: Player.Events) {
                val pos = player.currentPosition.coerceAtLeast(0)
                val dur = player.duration.takeIf { it > 0 } ?: 1L
                miniProgress.progress = ((pos * 100) / dur).toInt()
            }
        })

        btnPlayPause.setOnClickListener {
            if (c.isPlaying) c.pause() else c.play()
        }
        btnNext.setOnClickListener { c.seekToNextMediaItem() }
        btnPrev.setOnClickListener { c.seekToPreviousMediaItem() }
        btnShuffle.setOnClickListener { c.shuffleModeEnabled = !c.shuffleModeEnabled }
        btnRepeat.setOnClickListener {
            val next = when (c.repeatMode) {
                Player.REPEAT_MODE_OFF -> Player.REPEAT_MODE_ONE
                Player.REPEAT_MODE_ONE -> Player.REPEAT_MODE_ALL
                else -> Player.REPEAT_MODE_OFF
            }
            c.repeatMode = next
        }

        // Smooth mini-bar entry animation
        miniBar.apply {
            scaleX = 0.96f; scaleY = 0.96f; alpha = 0f; translationZ = 24f
            animate().alpha(1f).scaleX(1f).scaleY(1f).setDuration(280).start()
        }

        // Progress updater (UI)
        scope.launch {
            while (isActive) {
                c.currentPosition // just touching it
                val dur = c.duration.takeIf { it > 0 } ?: 1L
                if (dur > 0) {
                    val p = ((c.currentPosition * 100) / dur).toInt().coerceIn(0, 100)
                    miniProgress.progress = p
                }
                delay(300.milliseconds)
            }
        }
    }

    override fun onDestroy() {
        scope.cancel()
        controller?.release()
        super.onDestroy()
    }
}